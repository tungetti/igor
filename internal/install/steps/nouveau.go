// Package steps provides installation step implementations for Igor.
// Each step represents a discrete phase of the NVIDIA driver installation process.
package steps

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/tungetti/igor/internal/constants"
	"github.com/tungetti/igor/internal/gpu/nouveau"
	"github.com/tungetti/igor/internal/install"
)

// State keys for Nouveau blacklist configuration.
const (
	// StateNouveauBlacklisted indicates whether the Nouveau driver was blacklisted by this step.
	StateNouveauBlacklisted = "nouveau_blacklisted"
	// StateNouveauBlacklistFile stores the path to the blacklist file that was created.
	StateNouveauBlacklistFile = "nouveau_blacklist_file"
)

// DefaultBlacklistPath is the default path for the Nouveau blacklist configuration file.
const DefaultBlacklistPath = "/etc/modprobe.d/blacklist-nouveau.conf"

// blacklistContent is the content of the Nouveau blacklist configuration file.
const blacklistContent = `# Blacklist Nouveau driver for NVIDIA proprietary driver
# Generated by Igor NVIDIA Installer
blacklist nouveau
options nouveau modeset=0
`

// NouveauBlacklistStep blacklists the Nouveau open-source driver before installing
// proprietary NVIDIA drivers. This is a required step because Nouveau and the
// proprietary NVIDIA driver cannot coexist.
type NouveauBlacklistStep struct {
	install.BaseStep
	blacklistPath string
	detector      nouveau.Detector
	skipInitramfs bool
	fileWriter    FileWriter
}

// FileWriter abstracts file writing operations for testing.
// In production, this uses shell commands via the executor.
type FileWriter interface {
	WriteFile(ctx context.Context, path, content string, executor interface{}) error
	RemoveFile(ctx context.Context, path string, executor interface{}) error
}

// NouveauBlacklistStepOption configures the NouveauBlacklistStep.
type NouveauBlacklistStepOption func(*NouveauBlacklistStep)

// WithBlacklistPath sets a custom path for the blacklist file.
// This is useful for testing or when the default path is not appropriate.
func WithBlacklistPath(path string) NouveauBlacklistStepOption {
	return func(s *NouveauBlacklistStep) {
		s.blacklistPath = path
	}
}

// WithNouveauDetector sets a custom Nouveau detector.
// This is primarily used for testing.
func WithNouveauDetector(detector nouveau.Detector) NouveauBlacklistStepOption {
	return func(s *NouveauBlacklistStep) {
		s.detector = detector
	}
}

// WithSkipInitramfs configures whether to skip the initramfs update.
// This is useful for testing or when the initramfs update is handled separately.
func WithSkipInitramfs(skip bool) NouveauBlacklistStepOption {
	return func(s *NouveauBlacklistStep) {
		s.skipInitramfs = skip
	}
}

// WithFileWriter sets a custom file writer implementation.
// This is primarily used for testing.
func WithFileWriter(writer FileWriter) NouveauBlacklistStepOption {
	return func(s *NouveauBlacklistStep) {
		s.fileWriter = writer
	}
}

// NewNouveauBlacklistStep creates a new NouveauBlacklistStep with the given options.
func NewNouveauBlacklistStep(opts ...NouveauBlacklistStepOption) *NouveauBlacklistStep {
	s := &NouveauBlacklistStep{
		BaseStep:      install.NewBaseStep("nouveau_blacklist", "Blacklist Nouveau driver", true),
		blacklistPath: DefaultBlacklistPath,
		skipInitramfs: false,
	}

	for _, opt := range opts {
		opt(s)
	}

	return s
}

// Execute blacklists the Nouveau driver by creating a modprobe configuration file
// and regenerating the initramfs. If Nouveau is already blacklisted, the step
// is skipped.
func (s *NouveauBlacklistStep) Execute(ctx *install.Context) install.StepResult {
	startTime := time.Now()

	// Check for cancellation
	if ctx.IsCancelled() {
		return install.FailStep("step cancelled", context.Canceled)
	}

	ctx.LogDebug("starting Nouveau blacklist configuration")

	// Validate prerequisites
	if err := s.Validate(ctx); err != nil {
		return install.FailStep("validation failed", err).WithDuration(time.Since(startTime))
	}

	// Get or create detector
	detector := s.getDetector()

	// Check if Nouveau is already blacklisted
	blacklisted, err := detector.IsBlacklisted(ctx.Context())
	if err != nil {
		ctx.LogWarn("failed to check Nouveau blacklist status, proceeding anyway", "error", err)
	} else if blacklisted {
		ctx.Log("Nouveau driver is already blacklisted")
		return install.SkipStep("Nouveau driver is already blacklisted").
			WithDuration(time.Since(startTime))
	}

	// Check for cancellation
	if ctx.IsCancelled() {
		return install.FailStep("step cancelled", context.Canceled).WithDuration(time.Since(startTime))
	}

	// Dry run mode
	if ctx.DryRun {
		ctx.Log("dry run: would create blacklist file", "path", s.blacklistPath)
		if !s.skipInitramfs {
			cmd, args := s.getInitramfsCommand(s.getDistroFamily(ctx))
			ctx.Log("dry run: would regenerate initramfs", "command", cmd, "args", args)
		}
		return install.CompleteStep("dry run: Nouveau would be blacklisted").
			WithDuration(time.Since(startTime))
	}

	// Create the blacklist file
	ctx.Log("creating Nouveau blacklist file", "path", s.blacklistPath)
	if err := s.writeBlacklistFile(ctx); err != nil {
		ctx.LogError("failed to create blacklist file", "path", s.blacklistPath, "error", err)
		return install.FailStep("failed to create blacklist file", err).
			WithDuration(time.Since(startTime))
	}

	// Check for cancellation before initramfs update
	if ctx.IsCancelled() {
		// Try to rollback the file we just created
		_ = s.removeBlacklistFile(ctx)
		return install.FailStep("step cancelled", context.Canceled).
			WithDuration(time.Since(startTime))
	}

	// Regenerate initramfs unless skipped
	if !s.skipInitramfs {
		ctx.Log("regenerating initramfs")
		if err := s.regenerateInitramfs(ctx); err != nil {
			ctx.LogError("failed to regenerate initramfs", "error", err)
			// Try to rollback the blacklist file
			rollbackErr := s.removeBlacklistFile(ctx)
			if rollbackErr != nil {
				ctx.LogError("failed to rollback blacklist file", "error", rollbackErr)
			}
			return install.FailStep("failed to regenerate initramfs", err).
				WithDuration(time.Since(startTime))
		}
		ctx.LogDebug("initramfs regenerated successfully")
	}

	// Store state for rollback
	ctx.SetState(StateNouveauBlacklisted, true)
	ctx.SetState(StateNouveauBlacklistFile, s.blacklistPath)

	ctx.Log("Nouveau driver blacklisted successfully", "path", s.blacklistPath)
	return install.CompleteStep("Nouveau driver blacklisted successfully").
		WithDuration(time.Since(startTime)).
		WithCanRollback(true)
}

// Rollback removes the blacklist file that was created and regenerates the initramfs.
// If no blacklist file was created by this step, this is a no-op.
func (s *NouveauBlacklistStep) Rollback(ctx *install.Context) error {
	// Check if we actually created a blacklist file
	if !ctx.GetStateBool(StateNouveauBlacklisted) {
		ctx.LogDebug("no blacklist file was created, nothing to rollback")
		return nil
	}

	blacklistPath := ctx.GetStateString(StateNouveauBlacklistFile)
	if blacklistPath == "" {
		ctx.LogDebug("blacklist file path not found in state, nothing to rollback")
		return nil
	}

	// Validate executor
	if ctx.Executor == nil {
		return fmt.Errorf("executor not available for rollback")
	}

	ctx.Log("rolling back Nouveau blacklist", "path", blacklistPath)

	// Remove the blacklist file
	if err := s.removeBlacklistFileAtPath(ctx, blacklistPath); err != nil {
		ctx.LogError("failed to remove blacklist file during rollback", "path", blacklistPath, "error", err)
		return fmt.Errorf("failed to remove blacklist file '%s': %w", blacklistPath, err)
	}

	// Regenerate initramfs unless skipped
	if !s.skipInitramfs {
		ctx.Log("regenerating initramfs after rollback")
		if err := s.regenerateInitramfs(ctx); err != nil {
			ctx.LogError("failed to regenerate initramfs during rollback", "error", err)
			return fmt.Errorf("failed to regenerate initramfs: %w", err)
		}
	}

	// Clear state
	ctx.DeleteState(StateNouveauBlacklisted)
	ctx.DeleteState(StateNouveauBlacklistFile)

	ctx.LogDebug("Nouveau blacklist rollback completed")
	return nil
}

// Validate checks if the step can be executed with the given context.
// It ensures the Executor is available for running commands.
func (s *NouveauBlacklistStep) Validate(ctx *install.Context) error {
	if ctx.Executor == nil {
		return fmt.Errorf("executor is required for Nouveau blacklist configuration")
	}
	return nil
}

// CanRollback returns true since blacklist configuration can be rolled back.
func (s *NouveauBlacklistStep) CanRollback() bool {
	return true
}

// getDetector returns the configured detector or creates a new one.
func (s *NouveauBlacklistStep) getDetector() nouveau.Detector {
	if s.detector != nil {
		return s.detector
	}
	return nouveau.NewDetector()
}

// getDistroFamily returns the distribution family from the context.
func (s *NouveauBlacklistStep) getDistroFamily(ctx *install.Context) constants.DistroFamily {
	if ctx.DistroInfo != nil {
		return ctx.DistroInfo.Family
	}
	return constants.FamilyUnknown
}

// getInitramfsCommand returns the appropriate initramfs regeneration command
// for the given distribution family.
func (s *NouveauBlacklistStep) getInitramfsCommand(family constants.DistroFamily) (string, []string) {
	switch family {
	case constants.FamilyDebian:
		return "update-initramfs", []string{"-u"}
	case constants.FamilyRHEL, constants.FamilySUSE:
		return "dracut", []string{"--force"}
	case constants.FamilyArch:
		return "mkinitcpio", []string{"-P"}
	default:
		// Fallback to Debian-style command
		return "update-initramfs", []string{"-u"}
	}
}

// writeBlacklistFile creates the Nouveau blacklist configuration file.
func (s *NouveauBlacklistStep) writeBlacklistFile(ctx *install.Context) error {
	if s.fileWriter != nil {
		return s.fileWriter.WriteFile(ctx.Context(), s.blacklistPath, blacklistContent, ctx.Executor)
	}

	// Use shell command to write file as root
	// We use tee to write to the file, which handles the privilege escalation
	result := ctx.Executor.ExecuteWithInput(
		ctx.Context(),
		[]byte(blacklistContent),
		"tee",
		s.blacklistPath,
	)

	if result.ExitCode != 0 {
		errMsg := strings.TrimSpace(string(result.Stderr))
		if errMsg == "" {
			errMsg = "unknown error"
		}
		return fmt.Errorf("failed to write blacklist file: %s", errMsg)
	}

	return nil
}

// removeBlacklistFile removes the blacklist file at the configured path.
func (s *NouveauBlacklistStep) removeBlacklistFile(ctx *install.Context) error {
	return s.removeBlacklistFileAtPath(ctx, s.blacklistPath)
}

// removeBlacklistFileAtPath removes the blacklist file at the specified path.
func (s *NouveauBlacklistStep) removeBlacklistFileAtPath(ctx *install.Context, path string) error {
	if s.fileWriter != nil {
		return s.fileWriter.RemoveFile(ctx.Context(), path, ctx.Executor)
	}

	result := ctx.Executor.ExecuteElevated(ctx.Context(), "rm", "-f", path)

	if result.ExitCode != 0 {
		errMsg := strings.TrimSpace(string(result.Stderr))
		if errMsg == "" {
			errMsg = "unknown error"
		}
		return fmt.Errorf("failed to remove blacklist file: %s", errMsg)
	}

	return nil
}

// regenerateInitramfs regenerates the initramfs using the appropriate command
// for the current distribution.
func (s *NouveauBlacklistStep) regenerateInitramfs(ctx *install.Context) error {
	cmd, args := s.getInitramfsCommand(s.getDistroFamily(ctx))

	ctx.LogDebug("executing initramfs command", "command", cmd, "args", args)

	result := ctx.Executor.ExecuteElevated(ctx.Context(), cmd, args...)

	if result.ExitCode != 0 {
		errMsg := strings.TrimSpace(string(result.Stderr))
		if errMsg == "" {
			errMsg = strings.TrimSpace(string(result.Stdout))
		}
		if errMsg == "" {
			errMsg = "unknown error"
		}
		return fmt.Errorf("initramfs command failed: %s", errMsg)
	}

	return nil
}

// Ensure NouveauBlacklistStep implements the Step interface.
var _ install.Step = (*NouveauBlacklistStep)(nil)
