// Package steps provides installation step implementations for Igor.
// Each step represents a discrete phase of the NVIDIA driver installation process.
package steps

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/tungetti/igor/internal/install"
)

// State keys for X.org configuration.
const (
	// StateXorgConfigured indicates whether X.org was configured by this step.
	StateXorgConfigured = "xorg_configured"
	// StateXorgConfigPath stores the path to the created config file.
	StateXorgConfigPath = "xorg_config_path"
	// StateXorgBackupPath stores the path to the backup if existing config was found.
	StateXorgBackupPath = "xorg_backup_path"
	// StateXorgDisplayServer stores the detected display server (xorg, wayland, unknown).
	StateXorgDisplayServer = "xorg_display_server"
)

// Default values for X.org configuration.
const (
	// DefaultXorgConfDir is the default X.org configuration directory.
	DefaultXorgConfDir = "/etc/X11/xorg.conf.d"
	// DefaultXorgConfFile is the default X.org configuration file name.
	DefaultXorgConfFile = "20-nvidia.conf"
	// DefaultXorgConfPath is the default full path to the X.org configuration file.
	DefaultXorgConfPath = "/etc/X11/xorg.conf.d/20-nvidia.conf"
)

// NvidiaXorgConfig is the NVIDIA X.org configuration template.
const NvidiaXorgConfig = `# NVIDIA driver configuration
# Generated by Igor

Section "OutputClass"
    Identifier "nvidia"
    MatchDriver "nvidia-drm"
    Driver "nvidia"
    Option "AllowEmptyInitialConfiguration"
    Option "PrimaryGPU" "yes"
    ModulePath "/usr/lib/x86_64-linux-gnu/nvidia/xorg"
EndSection
`

// XorgFileWriter interface for file operations (allows testing).
type XorgFileWriter interface {
	WriteFile(path string, content []byte, perm os.FileMode) error
	MkdirAll(path string, perm os.FileMode) error
	Stat(path string) (os.FileInfo, error)
	Rename(oldpath, newpath string) error
	Remove(path string) error
	ReadFile(path string) ([]byte, error)
}

// RealXorgFileWriter implements XorgFileWriter using the real filesystem.
type RealXorgFileWriter struct{}

// WriteFile writes content to a file.
func (r *RealXorgFileWriter) WriteFile(path string, content []byte, perm os.FileMode) error {
	return os.WriteFile(path, content, perm)
}

// MkdirAll creates a directory and all parents.
func (r *RealXorgFileWriter) MkdirAll(path string, perm os.FileMode) error {
	return os.MkdirAll(path, perm)
}

// Stat returns file info.
func (r *RealXorgFileWriter) Stat(path string) (os.FileInfo, error) {
	return os.Stat(path)
}

// Rename renames/moves a file.
func (r *RealXorgFileWriter) Rename(oldpath, newpath string) error {
	return os.Rename(oldpath, newpath)
}

// Remove removes a file.
func (r *RealXorgFileWriter) Remove(path string) error {
	return os.Remove(path)
}

// ReadFile reads file content.
func (r *RealXorgFileWriter) ReadFile(path string) ([]byte, error) {
	return os.ReadFile(path)
}

// DisplayDetector interface for detecting display server.
type DisplayDetector interface {
	DetectDisplayServer(ctx context.Context) (string, error) // Returns "xorg", "wayland", or "unknown"
	IsWaylandSession() bool
}

// RealDisplayDetector implements DisplayDetector using system commands.
type RealDisplayDetector struct{}

// DetectDisplayServer detects the current display server.
func (r *RealDisplayDetector) DetectDisplayServer(ctx context.Context) (string, error) {
	// Check XDG_SESSION_TYPE environment variable first
	sessionType := os.Getenv("XDG_SESSION_TYPE")
	if sessionType == "wayland" {
		return "wayland", nil
	}
	if sessionType == "x11" {
		return "xorg", nil
	}

	// Check WAYLAND_DISPLAY
	waylandDisplay := os.Getenv("WAYLAND_DISPLAY")
	if waylandDisplay != "" {
		return "wayland", nil
	}

	// Check DISPLAY (X11)
	display := os.Getenv("DISPLAY")
	if display != "" {
		return "xorg", nil
	}

	return "unknown", nil
}

// IsWaylandSession returns true if running under Wayland.
func (r *RealDisplayDetector) IsWaylandSession() bool {
	sessionType := os.Getenv("XDG_SESSION_TYPE")
	if sessionType == "wayland" {
		return true
	}
	waylandDisplay := os.Getenv("WAYLAND_DISPLAY")
	return waylandDisplay != ""
}

// XorgConfigStep configures X.org for NVIDIA driver.
type XorgConfigStep struct {
	install.BaseStep
	configDir       string          // Config directory (default: /etc/X11/xorg.conf.d)
	configFile      string          // Config file name (default: 20-nvidia.conf)
	configContent   string          // Custom config content (optional)
	skipIfWayland   bool            // Skip configuration if Wayland is detected
	backupExisting  bool            // Backup existing config before overwriting
	fileWriter      XorgFileWriter  // For writing files (testing)
	displayDetector DisplayDetector // For detecting display server (testing)
}

// XorgConfigStepOption configures the XorgConfigStep.
type XorgConfigStepOption func(*XorgConfigStep)

// WithXorgConfigDir sets the config directory.
func WithXorgConfigDir(dir string) XorgConfigStepOption {
	return func(s *XorgConfigStep) {
		s.configDir = dir
	}
}

// WithXorgConfigFile sets the config file name.
func WithXorgConfigFile(file string) XorgConfigStepOption {
	return func(s *XorgConfigStep) {
		s.configFile = file
	}
}

// WithXorgConfigContent sets custom config content.
func WithXorgConfigContent(content string) XorgConfigStepOption {
	return func(s *XorgConfigStep) {
		s.configContent = content
	}
}

// WithSkipIfWayland configures whether to skip if Wayland is detected.
func WithSkipIfWayland(skip bool) XorgConfigStepOption {
	return func(s *XorgConfigStep) {
		s.skipIfWayland = skip
	}
}

// WithBackupExisting configures whether to backup existing config.
func WithBackupExisting(backup bool) XorgConfigStepOption {
	return func(s *XorgConfigStep) {
		s.backupExisting = backup
	}
}

// WithXorgFileWriter sets a custom file writer for testing.
func WithXorgFileWriter(writer XorgFileWriter) XorgConfigStepOption {
	return func(s *XorgConfigStep) {
		s.fileWriter = writer
	}
}

// WithDisplayDetector sets a custom display detector for testing.
func WithDisplayDetector(detector DisplayDetector) XorgConfigStepOption {
	return func(s *XorgConfigStep) {
		s.displayDetector = detector
	}
}

// NewXorgConfigStep creates a new XorgConfigStep with the given options.
func NewXorgConfigStep(opts ...XorgConfigStepOption) *XorgConfigStep {
	s := &XorgConfigStep{
		BaseStep:       install.NewBaseStep("xorg_config", "Configure X.org for NVIDIA driver", true),
		configDir:      DefaultXorgConfDir,
		configFile:     DefaultXorgConfFile,
		configContent:  NvidiaXorgConfig,
		skipIfWayland:  false,
		backupExisting: true,
	}

	for _, opt := range opts {
		opt(s)
	}

	return s
}

// Execute configures X.org for the NVIDIA driver.
// It performs the following steps:
//  1. Checks for cancellation
//  2. Validates prerequisites (executor available)
//  3. Detects display server (Wayland vs X.org)
//  4. If Wayland and skipIfWayland=true, returns SkipStep with info message
//  5. Checks if config directory exists, creates if not
//  6. Checks if config file already exists
//  7. If exists and backupExisting=true, backup to .bak
//  8. In dry-run mode, logs what would be created
//  9. Writes the NVIDIA X.org configuration file
//  10. Stores state for rollback
//  11. Returns success
func (s *XorgConfigStep) Execute(ctx *install.Context) install.StepResult {
	startTime := time.Now()

	// Check for cancellation
	if ctx.IsCancelled() {
		return install.FailStep("step cancelled", context.Canceled)
	}

	ctx.LogDebug("starting X.org configuration")

	// Validate prerequisites
	if err := s.Validate(ctx); err != nil {
		return install.FailStep("validation failed", err).WithDuration(time.Since(startTime))
	}

	// Check for cancellation
	if ctx.IsCancelled() {
		return install.FailStep("step cancelled", context.Canceled).WithDuration(time.Since(startTime))
	}

	// Detect display server
	displayServer, err := s.detectDisplayServer(ctx)
	if err != nil {
		ctx.LogWarn("failed to detect display server, proceeding anyway", "error", err)
		displayServer = "unknown"
	}
	ctx.LogDebug("detected display server", "type", displayServer)

	// Store display server in state for reference
	ctx.SetState(StateXorgDisplayServer, displayServer)

	// If Wayland and skipIfWayland, skip the step
	if displayServer == "wayland" && s.skipIfWayland {
		ctx.Log("Wayland session detected, skipping X.org configuration")
		return install.SkipStep("Wayland session detected, X.org configuration not needed").
			WithDuration(time.Since(startTime))
	}

	// Check for cancellation
	if ctx.IsCancelled() {
		return install.FailStep("step cancelled", context.Canceled).WithDuration(time.Since(startTime))
	}

	// Get full config path
	configPath := filepath.Join(s.configDir, s.configFile)

	// Create config directory if needed
	if err := s.createConfigDir(ctx); err != nil {
		ctx.LogError("failed to create config directory", "path", s.configDir, "error", err)
		return install.FailStep("failed to create config directory", err).
			WithDuration(time.Since(startTime))
	}

	// Check for cancellation
	if ctx.IsCancelled() {
		return install.FailStep("step cancelled", context.Canceled).WithDuration(time.Since(startTime))
	}

	// Check if config file already exists and backup if needed
	var backupPath string
	if s.backupExisting {
		var backupErr error
		backupPath, backupErr = s.backupExistingConfig(ctx)
		if backupErr != nil {
			ctx.LogWarn("failed to backup existing config", "error", backupErr)
			// Continue anyway - backup is optional
		}
	}

	// Dry run mode
	if ctx.DryRun {
		ctx.Log("dry run: would create X.org config file", "path", configPath)
		if backupPath != "" {
			ctx.Log("dry run: would backup existing config to", "path", backupPath)
		}
		return install.CompleteStep("dry run: X.org configuration would be created").
			WithDuration(time.Since(startTime))
	}

	// Check for cancellation before writing
	if ctx.IsCancelled() {
		return install.FailStep("step cancelled", context.Canceled).WithDuration(time.Since(startTime))
	}

	// Write the config file
	ctx.Log("creating X.org configuration file", "path", configPath)
	if err := s.writeConfig(ctx); err != nil {
		ctx.LogError("failed to write X.org config file", "path", configPath, "error", err)
		return install.FailStep("failed to write X.org config file", err).
			WithDuration(time.Since(startTime))
	}

	// Store state for rollback
	ctx.SetState(StateXorgConfigured, true)
	ctx.SetState(StateXorgConfigPath, configPath)
	if backupPath != "" {
		ctx.SetState(StateXorgBackupPath, backupPath)
	}

	ctx.Log("X.org configured successfully for NVIDIA driver", "path", configPath)
	return install.CompleteStep("X.org configured successfully for NVIDIA driver").
		WithDuration(time.Since(startTime)).
		WithCanRollback(true)
}

// Rollback removes the X.org configuration file that was created.
// If a backup exists, it restores the original configuration.
func (s *XorgConfigStep) Rollback(ctx *install.Context) error {
	// Check if we actually created a config file
	if !ctx.GetStateBool(StateXorgConfigured) {
		ctx.LogDebug("no X.org config was created, nothing to rollback")
		return nil
	}

	configPath := ctx.GetStateString(StateXorgConfigPath)
	if configPath == "" {
		ctx.LogDebug("X.org config path not found in state, nothing to rollback")
		return nil
	}

	// Validate executor
	if ctx.Executor == nil {
		return fmt.Errorf("executor not available for rollback")
	}

	ctx.Log("rolling back X.org configuration", "path", configPath)

	// Remove the config file
	if err := s.removeConfig(ctx, configPath); err != nil {
		ctx.LogError("failed to remove X.org config file during rollback", "path", configPath, "error", err)
		return fmt.Errorf("failed to remove X.org config file '%s': %w", configPath, err)
	}

	// Restore backup if it exists
	backupPath := ctx.GetStateString(StateXorgBackupPath)
	if backupPath != "" {
		ctx.Log("restoring X.org config from backup", "backup", backupPath)
		if err := s.restoreBackup(ctx, backupPath, configPath); err != nil {
			ctx.LogError("failed to restore backup", "backup", backupPath, "error", err)
			return fmt.Errorf("failed to restore backup '%s': %w", backupPath, err)
		}
	}

	// Clear state
	ctx.DeleteState(StateXorgConfigured)
	ctx.DeleteState(StateXorgConfigPath)
	ctx.DeleteState(StateXorgBackupPath)
	ctx.DeleteState(StateXorgDisplayServer)

	ctx.LogDebug("X.org configuration rollback completed")
	return nil
}

// Validate checks if the step can be executed with the given context.
// It ensures the Executor is available and validates paths for security.
func (s *XorgConfigStep) Validate(ctx *install.Context) error {
	if ctx.Executor == nil {
		return fmt.Errorf("executor is required for X.org configuration")
	}

	// Validate config directory path (prevent command injection)
	if !isValidXorgPath(s.configDir) {
		return fmt.Errorf("invalid config directory path: %q", s.configDir)
	}

	// Validate config file name (prevent path traversal)
	if !isValidXorgFileName(s.configFile) {
		return fmt.Errorf("invalid config file name: %q", s.configFile)
	}

	return nil
}

// CanRollback returns true since X.org configuration can be rolled back.
func (s *XorgConfigStep) CanRollback() bool {
	return true
}

// detectDisplayServer detects whether the session is using Wayland or X.org.
func (s *XorgConfigStep) detectDisplayServer(ctx *install.Context) (string, error) {
	// Use injected detector if available
	if s.displayDetector != nil {
		return s.displayDetector.DetectDisplayServer(ctx.Context())
	}

	// Use real detector
	detector := &RealDisplayDetector{}
	return detector.DetectDisplayServer(ctx.Context())
}

// createConfigDir creates the config directory if it doesn't exist.
func (s *XorgConfigStep) createConfigDir(ctx *install.Context) error {
	writer := s.getFileWriter()

	// Check if directory exists
	_, err := writer.Stat(s.configDir)
	if err == nil {
		// Directory exists
		return nil
	}

	if !os.IsNotExist(err) {
		return fmt.Errorf("failed to check directory: %w", err)
	}

	// Directory doesn't exist
	if ctx.DryRun {
		ctx.LogDebug("dry run: would create config directory", "path", s.configDir)
		return nil
	}

	// Create directory using elevated command
	ctx.LogDebug("creating config directory", "path", s.configDir)

	result := ctx.Executor.ExecuteElevated(ctx.Context(), "mkdir", "-p", s.configDir)
	if result.ExitCode != 0 {
		errMsg := strings.TrimSpace(string(result.Stderr))
		if errMsg == "" {
			errMsg = "unknown error"
		}
		return fmt.Errorf("failed to create directory: %s", errMsg)
	}

	return nil
}

// backupExistingConfig backs up an existing config file if it exists.
// Returns the backup path if a backup was created, empty string otherwise.
func (s *XorgConfigStep) backupExistingConfig(ctx *install.Context) (string, error) {
	configPath := filepath.Join(s.configDir, s.configFile)
	writer := s.getFileWriter()

	// Check if config file exists
	_, err := writer.Stat(configPath)
	if os.IsNotExist(err) {
		// No existing config, nothing to backup
		return "", nil
	}
	if err != nil {
		return "", fmt.Errorf("failed to check existing config: %w", err)
	}

	// Create backup path
	backupPath := configPath + ".bak"

	// In dry-run mode, just report what would happen
	if ctx.DryRun {
		ctx.LogDebug("dry run: would backup existing config", "from", configPath, "to", backupPath)
		return backupPath, nil
	}

	ctx.LogDebug("backing up existing config", "from", configPath, "to", backupPath)

	// Use elevated command to copy the file
	result := ctx.Executor.ExecuteElevated(ctx.Context(), "cp", configPath, backupPath)
	if result.ExitCode != 0 {
		errMsg := strings.TrimSpace(string(result.Stderr))
		if errMsg == "" {
			errMsg = "unknown error"
		}
		return "", fmt.Errorf("failed to backup config: %s", errMsg)
	}

	return backupPath, nil
}

// writeConfig writes the NVIDIA X.org configuration file.
func (s *XorgConfigStep) writeConfig(ctx *install.Context) error {
	configPath := filepath.Join(s.configDir, s.configFile)
	content := s.configContent

	// Use tee for elevated file writing (same pattern as nouveau.go)
	result := ctx.Executor.ExecuteWithInput(
		ctx.Context(),
		[]byte(content),
		"tee",
		configPath,
	)

	if result.ExitCode != 0 {
		errMsg := strings.TrimSpace(string(result.Stderr))
		if errMsg == "" {
			errMsg = "unknown error"
		}
		return fmt.Errorf("failed to write config file: %s", errMsg)
	}

	return nil
}

// removeConfig removes the config file at the specified path.
func (s *XorgConfigStep) removeConfig(ctx *install.Context, configPath string) error {
	// Validate path for defense in depth
	if configPath == "" || !isValidXorgPath(configPath) {
		return fmt.Errorf("invalid config path for removal: %q", configPath)
	}

	result := ctx.Executor.ExecuteElevated(ctx.Context(), "rm", "-f", configPath)

	if result.ExitCode != 0 {
		errMsg := strings.TrimSpace(string(result.Stderr))
		if errMsg == "" {
			errMsg = "unknown error"
		}
		return fmt.Errorf("failed to remove config file: %s", errMsg)
	}

	return nil
}

// restoreBackup restores a config file from backup.
func (s *XorgConfigStep) restoreBackup(ctx *install.Context, backupPath, configPath string) error {
	// Validate paths for defense in depth
	if backupPath == "" || !isValidXorgPath(backupPath) {
		return fmt.Errorf("invalid backup path: %q", backupPath)
	}
	if configPath == "" || !isValidXorgPath(configPath) {
		return fmt.Errorf("invalid config path for restore: %q", configPath)
	}

	result := ctx.Executor.ExecuteElevated(ctx.Context(), "mv", backupPath, configPath)

	if result.ExitCode != 0 {
		errMsg := strings.TrimSpace(string(result.Stderr))
		if errMsg == "" {
			errMsg = "unknown error"
		}
		return fmt.Errorf("failed to restore backup: %s", errMsg)
	}

	return nil
}

// getFileWriter returns the file writer (real or mock).
func (s *XorgConfigStep) getFileWriter() XorgFileWriter {
	if s.fileWriter != nil {
		return s.fileWriter
	}
	return &RealXorgFileWriter{}
}

// isValidXorgPath checks if a path is valid (no command injection characters).
func isValidXorgPath(path string) bool {
	if path == "" {
		return false
	}
	// Check for dangerous characters
	dangerousChars := []string{";", "&", "|", "`", "$", "(", ")", "{", "}", "<", ">", "!", "\n", "\r"}
	for _, char := range dangerousChars {
		if strings.Contains(path, char) {
			return false
		}
	}
	return true
}

// isValidXorgFileName checks if a file name is valid (no path traversal).
func isValidXorgFileName(name string) bool {
	if name == "" {
		return false
	}
	// Check for path traversal
	if strings.Contains(name, "/") || strings.Contains(name, "\\") {
		return false
	}
	if strings.Contains(name, "..") {
		return false
	}
	// Check for dangerous characters
	dangerousChars := []string{";", "&", "|", "`", "$", "(", ")", "{", "}", "<", ">", "!", "\n", "\r"}
	for _, char := range dangerousChars {
		if strings.Contains(name, char) {
			return false
		}
	}
	return true
}

// Ensure XorgConfigStep implements the Step interface.
var _ install.Step = (*XorgConfigStep)(nil)
